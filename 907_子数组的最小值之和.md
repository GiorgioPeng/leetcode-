# 思路：  
先求连续子数组，再逐个调用math中的Min方法  
```
/**
 * @param {number[]} A
 * @return {number}
 */
var sumSubarrayMins = function(A) {
    function add(num){    //找到所有子集
    if(num.length === 0)
    return [];
        let i = num.length-1;
        do{
            if(num[i]==0)
                {
                    num[i]+=1;
                    return num;
                }
            else
                {
                  num[i]=0;
                    i--;
                }
        }while(i>-1);
    };
    function findZ(arr){       //判断是不是连续子集
        let a = arr.length;
        let i = 0;
        for (; i < a; i++) {
         if(arr[i]===1)
             break;
         }
        for (; i < a; i++) {
         if(arr[i]===0)
             break;
         }
         for (; i < a; i++) {
          if(arr[i]===1)
            return false;
            }
         return true;
    };
    let pre = [];
    let arr = [];
    let sum = 0;
    let leng = A.length;
    for(let i =0;i<leng;i++)
        pre[i]=0;
    let tol = Math.pow(2,leng);
    let r = 0;
    for(let j = 0;j<tol;j++)
        {
            if(findZ(pre))
            {
              r = arr.length;
              arr[r]=[];
              for(i=0;i<leng;i++)
                {

                    if(pre[i]===1)
                        arr[r].push(A[i]);
                    

                }
              }
            add(pre);
        }

    for(i=0,leng=arr.length;i<leng;i++)
     if(arr[i].length!==0)
        sum+=Math.min.apply(Math,arr[i]);
    return sum;
};

```  
> 从一开始的内存不够到现在的超时，我已经找不到哪里可以再优化了，在我的机器上跑没问题，就是巨慢
毕竟O(2^n)的时间复杂度不是开玩笑的，后面的测试案例太变态了，感觉机器都要炮炸了  

**提交未通过，因为超时了**
